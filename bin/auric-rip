#!/bin/zsh -e

typeset fs_device=/dev/disk1
typeset scsi_device=1,0,0

typeset uid=$(id -u)
(( uid == 0 )) || exec sudo $0 "$@"
typeset user=${SUDO_USER:-nkuitse}

cd ~/music/
exec 3>> rip.log

typeset have_disc=false

main() {
    typeset opt silent=false paranoia=true
    while getopts :sPd: opt; do
        case $opt in
            (s) silent=true ;;
            (P) paranoia=false ;;
            (d) fs_device=$OPTARG ;;
        esac
    done
    log
    tlog 'Begin session'
    typeset id job etc move
    typeset -a ripargs
    integer t0 dur min sec err
    ripargs=( -no-hidden-track -x -vsummary,titles -cddb 1 -B )
    ! $paranoia || ripargs+=( -paranoia )
    while true; do
        emit 'Insert a disc or press Q to quit... '
        wait-for-disc

        job=$(randhash)
        note "Beginning job $job"

        t0=$SECONDS
        note 'CDDB lookup...'
        cd-discid $fs_device | read id etc
        if [[ -d disc-$id ]]; then
            eol
            eject-disc
            fatal "Disc $id appears to have been ripped already"
        fi

        mkdir -p tmp/$job
        cd tmp/$job

        note "Ripping..."
        cdda2wav -D $scsi_device $ripargs 2>&1 | tee cdda2wav.log | ${AURIC_BIN}/cdda2wav-watch | read newid
        err=${pipestatus[1]}
        chown -R $user .
        ### organize-disc

        cd -
        if (( err == 0 )); then
            move=true
            $silent || sono -A -g 0.5 ships-bell .
            note 'Disc ripped successfully'
            if [[ -z $newid ]]; then
                warn 'Disc ID not reported'
            elif [[ $newid != $id ]]; then
                id=$newid
                warn "Disc ID corrected to $id"
                if [[ -e disc-$id ]]; then
                    move=false
                    warn "Disc $id has already been ripped"
                fi
            fi
        else
            move=false
            $silent || sono loud/buzzer
            warn "Disc $id failed to rip"
        fi
        if $move; then
            mv tmp/$job disc-$id
        else
            warn "Job $job must be cleaned up manually"
        fi
        dur=$(( SECONDS - t0 ))
        min=$(( dur / 60 ))
        sec=$(( dur % 60 ))
        note "$(printf 'Disc %s completed in %2dm %2ds' $id $min $sec)"
        rlog ok "$(printf 'Disc %s : %2dm %2ds' $id $min $sec)"
        eject-disc
        eol
    done
}

wait-for-disc() {
    print WAITING >&2
    #? darb stop 2> /dev/null || fatal "Couldn\'t stop disk arbitrator"
    # [[ ! -e $fs_device ]] || { umount $fs_device; sleep 1 }
    while [[ ! -e $fs_device ]]; do
        read -k -s -t 1 || continue
        if [[ $REPLY == [Qq] ]]; then
            eol
            finish
            exit 0
        fi
    done
    eol
    have_disc=true
    # clear
}

organize-disc() {
    for f in audio_??.wav; do
        n=$(sprintf '%05d' ${f[7,8]})
        mkdir $n
        mv $f $n/master.wav
    done
    # touch is:disc
}

rlog() {
    typeset result=$1; shift
    printf -- '  %s %s\n' $result "$*" >&3
}

log() {
    print -- "$*" >&3
}

tlog() {
    print -P -l "%D{%Y-%m-%d %H:%M:%S} $*" >&3
    # print -P -- "------ %D{%Y-%m-%d %H:%M:%S} $*" >&3
}

eject-disc() {
    $have_disc || return 0
    #? darb start || fatal "Couldn\'t restart disk arbitrator"
    if drutil eject; then
        have_disc=false
        return 0
    fi
    integer tries=${1:-5}
    emit 'Ejecting disc...'
    while (( tries > 0 )); do
        umount $fs_device > /dev/null 2>&1 || true
        ! eject $fs_device  > /dev/null 2>&1 || break
        emit .
        sleep 1
        let tries--
    done
    have_disc=false
    eol
    # fatal "Couldn\'t eject disk"
}

randhash() {
    print -- $$ $RANDOM $SECONDS | openssl sha1 | awk '{ print $NF }'
}

TRAPINT() {
    set -x
    eject-disc 1 || true
    finish 'End of session (caught interrupt)'
    set +x
    return $(( 128 + $1 ))
}

TRAPEXIT() {
    integer err=$?
    eject-disc 1 || true
    finish
    exit $err
}

finish() {
    unsetopt localtraps
    TRAPEXIT() { }
    tlog ${1:-'End of session'}
}

emit() {
    print -n $'\e[1m'"$*" >&2
}

eol() {
    print $'\e[0m' >&2
}

note() {
    print $'\e[1m'"$*"$'\e[0m' >&2
}

warn() {
    print $'\e[33;1m'"$*"$'\e[0m' >&2
    rlog warn "$*"
}

fatal() {
    print $'\e[31;1m'"$*"$'\e[0m' >&2
    rlog error "$*"
    exit 2
}

main "$@"

