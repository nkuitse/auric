#!/bin/zsh -e

typeset fs_device=/dev/disk1
typeset scsi_device=1,0,0

typeset have_disc=false

### typeset uid=$(id -u)
### (( uid == 0 )) || exec sudo $0 "$@"
### typeset user=${SUDO_USER:-nkuitse}

export MUSIC AURIC_JOBDIR

main() {
    typeset opt silent=false paranoia=false ingest=false edit=false mktags=false
    while getopts :ietspd: opt; do
        case $opt in
            (i) ingest=true ;;
            (e) ingest=true; edit=true ;;
            (t) ingest=true; mktags=true ;;
            (s) silent=true ;;
            (p) paranoia=true ;;
            (d) fs_device=$OPTARG ;;
        esac
    done

    note 'Some disc operations require root'
    sudo -v

    cd ${MUSIC:=~/music}

    exec 3>> rip.log
    log
    tlog 'Begin session'
    typeset id job etc move
    typeset -a ripargs msg
    integer t0 dur min sec cdda2wav_err
    typeset blah numtracks disctitle
    ripargs=( -no-hidden-track -x -vsummary,titles -cddb 1 -B )
    ! $paranoia || ripargs+=( -paranoia )
    while true; do
        emit 'Insert a disc or press Q to quit... '
        wait-for-disc
        sudo -v

        job=$(randhash)
        note "Beginning job $job"

        t0=$SECONDS
        note 'CDDB lookup...'
        sudo umount $fs_device || true
        sudo cd-discid $fs_device | read id etc
        if [[ -d disc-$id ]]; then
            eol
            eject-disc
            fatal "Disc $id appears to have been ripped already"
        fi

        AURIC_JOBDIR=$MUSIC/tmp/$job
        mkdir -p $AURIC_JOBDIR
        cd $MUSIC/tmp/$job

        note "Ripping..."
        cdda2wav -D $scsi_device $ripargs 2>&1 | tee cdda2wav.log | auric cdex | tee cdda2wav.parse | while read -A msg; do
            case ${msg[1]} in
                (disc)  case ${msg[2]} in
                            (end)   break ;;
                        esac ;;
                (track) case ${msg[3]} in
                            (begin) sudo -v ;;
                        esac ;;
            esac
        done
        cdda2wav_err=${pipestatus[1]}
        note 'Ripping complete' status=$cdda2wav_err
        sed -n '2p; 3q' cdda2wav.parse | read blah blah newid numtracks disctitle
        ### chown -R $user .
        ### organize-disc

        if (( cdda2wav_err == 0 )); then
            move=true
            $silent || sono -A -g 0.5 ships-bell .
            note 'Disc ripped successfully'
            if [[ -z $newid ]]; then
                warn 'Disc ID not reported'
            elif [[ $newid != $id ]]; then
                id=$newid
                warn "Disc ID corrected to $id"
                if [[ -e disc-$id ]]; then
                    move=false
                    warn "Disc $id has already been ripped"
                fi
            fi
        else
            move=false
            $silent || sono loud/buzzer
            warn "Disc $id failed to rip"
        fi
        cd $MUSIC
        if $move; then
            mv tmp/$job disc-$id
            ! $ingest || auric ingest disc-$id
            ! $edit   || auric edit   disc-$id
            ! $mktags || auric mktags disc-$id
        else
            warn "Job $job must be cleaned up manually"
        fi
        dur=$(( SECONDS - t0 ))
        min=$(( dur / 60 ))
        sec=$(( dur % 60 ))
        note "$(printf 'Disc %s completed in %2dm %2ds' $id $min $sec)"
        rlog ok "$(printf 'Disc %s : %2dm %2ds' $id $min $sec)"
        eject-disc
        eol
    done
}

wait-for-disc() {
    # print WAITING >&2
    #? darb stop 2> /dev/null || fatal "Couldn\'t stop disk arbitrator"
    # [[ ! -e $fs_device ]] || { umount $fs_device; sleep 1 }
    while [[ ! -e $fs_device ]]; do
        read -k -s -t 1 || continue
        if [[ $REPLY == [Qq] ]]; then
            eol
            finish
            exit 0
        fi
    done
    eol
    have_disc=true
    # clear
}

organize-disc() {
    for f in audio_??.wav; do
        n=$(sprintf '%05d' ${f[7,8]})
        mkdir $n
        mv $f $n/master.wav
    done
    # touch is:disc
}

rlog() {
    typeset result=$1; shift
    printf -- '  %s %s\n' $result "$*" >&3
}

log() {
    print -- "$*" >&3
}

tlog() {
    print -P -l "%D{%Y-%m-%d %H:%M:%S} $*" >&3
    # print -P -- "------ %D{%Y-%m-%d %H:%M:%S} $*" >&3
}

eject-disc() {
    $have_disc || return 0
    #? darb start || fatal "Couldn\'t restart disk arbitrator"
    if sudo drutil eject; then
        have_disc=false
        return 0
    fi
    integer tries=${1:-5}
    emit 'Ejecting disc...'
    while (( tries > 0 )); do
        sudo umount $fs_device > /dev/null 2>&1 || true
        ! sudo eject $fs_device  > /dev/null 2>&1 || break
        emit .
        sleep 1
        let tries--
    done
    have_disc=false
    eol
    # fatal "Couldn\'t eject disk"
}

randhash() {
    print -- $$ $RANDOM $SECONDS | openssl sha1 | awk '{ print $NF }'
}

TRAPINT() {
    set -x
    eject-disc 1 || true
    finish 'End of session (caught interrupt)'
    set +x
    return $(( 128 + $1 ))
}

TRAPEXIT() {
    integer err=$?
    eject-disc 1 || true
    finish
    exit $err
}

finish() {
    unsetopt localtraps
    TRAPEXIT() { }
    tlog ${1:-'End of session'}
}

emit() {
    print -n $'\e[1m'"$*" >&2
}

eol() {
    print $'\e[0m' >&2
}

note() {
    print $'\e[1m'"$*"$'\e[0m' >&2
}

warn() {
    print $'\e[33;1m'"$*"$'\e[0m' >&2
    rlog warn "$*"
}

fatal() {
    print $'\e[31;1m'"$*"$'\e[0m' >&2
    rlog error "$*"
    exit 2
}

main "$@"

